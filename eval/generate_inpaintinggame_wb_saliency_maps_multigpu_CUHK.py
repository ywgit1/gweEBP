#!/usr/bin/env python3
import os
import glob
import dill as pickle
import multiprocessing as mp
from multiprocessing import Pool
from functools import partial
from pprint import pprint
import signal
import subprocess
import glob
import pandas as pd
import datetime
import pytz
import random

import sys
sys.path.append('../python')

import xfr

from xfr import inpaintgame3_dir

from create_wbnet import create_wbnet
from xfr.utils import iterate_param_sets
from xfr.utils import prune_unneeded_exports
from xfr.utils import normalize_gpus
from xfr.inpainting_game.generate_whitebox_saliency_CUHK import generate_wb_smaps
import torch
from tqdm import tqdm
import gc

def randomly(seq):
    # https://stackoverflow.com/a/9253366/249226
    shuffled = list(seq)
    random.shuffle(shuffled)
    return iter(shuffled)


def run_experiment(params, params_export, gpu_queue):
    import imp
    gpu_id = gpu_queue.get()
    # print("GPU: {}".format(gpu_id))
    process = None
    success = False
    try:
        # taa: This is a physical GPU ID, as generated by normalize_gpus() call
        # in run_experiments.

        if torch.cuda.is_available():
            device = torch.device("cuda:{}".format(gpu_id))
            # print("Running on {}".format(device))
        else:
            device = torch.device("cpu")
            # print("Running on CPU")
        
        device = torch.device("cpu") # Force running on CPU
        
        params['EXPER_DIR'] = (  # output directory
            'Note_20211029_Masks_for_Inpainting/' +
            ','.join([
                str(params[k][0]).replace('/', '-') for k in params_export if len(params[k])==1
            ]))

        # out_dir = os.path.join(
        #     os.path.dirname(__file__),
        #     'generated',
        #     ('{EXPER_DIR}'
        #     ).format(**params))

        if params['file'] is None:
            params['file'] = os.path.join(
                xfr.__path__[0],
                'inpainting_game/generate_whitebox_saliency_CUHK.py'
            )

        ebp_version = int(params['EBP_VER'][0])
        net_name = params['WB_NET'][0]
        
        wb = create_wbnet(
            net_name,
            ebp_version=ebp_version,
            ebp_subtree_mode=params['INIT_EBP_SUBTREE_MODE'][0],
            device=device,
        )
        
        if params['EBP_SUBTREE_MODE_WEIGHTED'][0] is None:
            if 'resnet' in net_name:
                subtree_mode_weighted = 'all'
            else:
                subtree_mode_weighted = 'affineonly_with_prior'

        ntp = generate_wb_smaps(
            wb=wb,
            net_name=net_name,
            img_base='img/%s' % params['IMG_NUM'][0],
            subj_id=params['SUBJECT_ID'][0],
            mask_id=params['MASK_ID'][0],
            subtree_mode_weighted=subtree_mode_weighted,
            ebp_ver=ebp_version,
            overwrite=params['overwrite'][0],
            device=device,
            method=params['method'][0],
        )
        success = True
        
        wb.to(torch.device("cpu"))
        del wb
        gc.collect()

    except TypeError as e:
        print("\n\n ERROR detected. The parameters are:")
        pprint(params)
        print("ERROR: {}".format(e))
        if params['debug']:
            raise e
    except Exception as e:
        print("ERROR: {}".format(e))
        if params['debug']:
            raise e
    finally:
        # process.terminate()
        # try:
        #     if process is not None:
        #         process.kill()
        # except OSError: # if process has already ended, don't throw error?
        #     pass
        gpu_queue.put(gpu_id)
    return success, (params, params_export), ntp

def run_experiments(params):
    params['overwrite'] = [params['overwrite']]
    oldGpus = params['gpus']
    newGpus = normalize_gpus(params['gpus'], True)
    m = mp.Manager()
    gpu_queue = m.Queue()

    for idx, gpu_id in enumerate(newGpus):
        print('Queueing GPU resource %d (%d)' % (int(gpu_id), oldGpus[idx]))
        gpu_queue.put(gpu_id)

    req_scale = (
        lambda params:
        params['MASKS_CONSTRUCTION'][0].lower() not in [
            'bbnet_mean_ebp', 'facial_regions'])

    params_export = [
        'SUBJECT_ID',
        'MASK_ID',
        'IMG_NUM',
        'WB_NET',
        'EBP_VER',
        'INIT_EBP_SUBTREE_MODE',
        'EBP_SUBTREE_MODE_WEIGHTED',
        # 'RISE_SCALE',
        'overwrite',
    ]
    # if params['SUBJECTS'] is None:
    #     params['SUBJECTS'] = []
    #     for subj_csv in params['SUBJ_CSV']:
    #         subj_data = pd.read_csv(subj_csv)
    #         params['SUBJECTS'].extend((
    #             subj_data['SUBJECT_ID'].map(str) + '/' +
    #             subj_data['ORIGINAL_FILE']).values
    #         )
    net_ds = {}
    subjects = set()
    for net_name in params['WB_NET']:
        uom_ds = pd.read_csv(
                os.path.join(
                    inpaintgame3_dir,
                    'filtered_masks_threshold-{}.csv'.format(net_name)
                ))

        uom_ds['IMG_NUM'] = [
            os.path.basename(fn)
            for fn in uom_ds['ORIGINAL_BASENAME'].values]

        net_ds[net_name] = uom_ds
        subjects.update(uom_ds['SUBJECT_ID'].unique().tolist())

    if params['SUBJECT_ID'] is None:
        params['SUBJECT_ID'] = list(subjects)
        params['SUBJECT_ID'].sort()
        params['SUBJECT_ID'] = params['SUBJECT_ID'][::-1]  # TEMPORARY
        params['SUBJECT_ID'] = [sid for sid in params['SUBJECT_ID']]

    def valid_imgnums(net_ds, params_):
        cuhk_ds = net_ds[params_['WB_NET'][0]]
        subset = cuhk_ds.loc[
            (cuhk_ds['SUBJECT_ID'] == params_['SUBJECT_ID'][0]) &
            (cuhk_ds['MASK_ID'] == int(params_['MASK_ID'][0])) &
            (cuhk_ds['TRIPLET_SET'] == 'PROBE')
        ]
        img_nums = subset['IMG_NUM'].unique()
        if params_['filter_img_nums']:
            img_nums = [img for img in img_nums if img in
                        params_['filter_img_nums']]
        return img_nums

    if not params['debug']:
        original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
        pool = Pool(len(params['gpus']))
        signal.signal(signal.SIGINT, original_sigint_handler)
        try:
            multiple_results = []
            param_iter = iterate_param_sets(params, params_export)
            if params['shuffle']:
                param_iter = randomly(param_iter)
            for params_ in param_iter:
                img_nums = valid_imgnums(net_ds, params_)
                for img_num in img_nums:
                    _params_ = params_.copy()
                    _params_['IMG_NUM'] = [img_num]

                    params_export_ = prune_unneeded_exports(
                        params_export, _params_)

                    multiple_results.append(
                        pool.apply_async(
                            run_experiment,
                            args=(_params_, params_export_),
                            kwds={'gpu_queue':gpu_queue},
                        )
                    )
            for ret in multiple_results:
                success, (params_, params_export_) = ret.get(999999999)
                if not success:
                    print('Process failed! Parameters:')
                    pprint(params_export_)
                    pprint(params_)
        except KeyboardInterrupt:
            print('Caught Keyboard interrupt signal.')
            pool.terminate()
        else:
            print('Finishing multiprocessing ...')
            pool.close()
            print('Finished multiprocessing normally'
                  ' (some processes may still be running).')
        pool.join()
        print('Joined pool')
    else:
        ntotal, ntp = 0, 0
        
        for params_ in tqdm(iterate_param_sets(params, params_export), total=len(params['SUBJECT_ID'])*len(params['MASK_ID'])):
            img_nums = valid_imgnums(net_ds, params_)
            ntotal += len(img_nums)
            for img_num in img_nums:
                _params_ = params_.copy()
                _params_['IMG_NUM'] = [img_num]

                params_export_ = prune_unneeded_exports(
                    params_export, _params_)

                ntp = ntp + run_experiment(_params_, params_export_, gpu_queue)[2]
                
        print('{}'.format(ntp / ntotal))

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(
        'Script for generating whitebox saliency maps in parallel.')

    parser.add_argument(
        '--gpu',
        '--gpus',
        dest='gpus',
        default=[0],
        nargs='+',
        help='space separated list of GPU ids to use.'
    )

    parser.add_argument('--debug', action='store_true')
    parser.add_argument('--dry-run', action='store_true', dest='dry_run')

    parser.add_argument(
        '--subjects', nargs='+', dest='SUBJECT_ID',
        default=None,
        help='restrict processing to specific subjects',
    )
    parser.add_argument(
        '--img-num', nargs='*', dest='filter_img_nums',
        default=None,
        type=int,
        help='restrict processing to specific subjects',
    )
    parser.add_argument(
        '--method', nargs='*',
        default=['gwecEBP'],
        type=str,
        help='restrict processing to specific subjects',
    )

    parser.add_argument(
        '--ebp-ver', nargs='+', dest='EBP_VER',
        default=['8'],
        help='EBP version to use (leave as default)',
        )
    parser.add_argument(
        '--init-ebp-subtree-mode', nargs='+',
        dest='INIT_EBP_SUBTREE_MODE',
        default=['affineonly'],
        # default=['affineonly_with_prior'],
        help='EBP subtree mode used in whitebox constructor.',
    )
    parser.add_argument(
        '--ebp-subtree-mode-weighted', nargs='+',
        dest='EBP_SUBTREE_MODE_WEIGHTED',
        default=[None],
        help='EBP subtree mode used in weighted_subtree_ebp call.',
    )
    parser.add_argument(
        '--mask', nargs='+', dest='MASK_ID',
        default=[
            '{}'.format(mask_id)  for mask_id in range(6)
        ],
        help='restrict processing to specific masks, zero padded',
    )
    parser.add_argument('--net', nargs='+',
                        default=['CUHK-vgg16'],
                        dest='WB_NET')

    parser.add_argument(
        '--overwrite',
        action='store_true',
        help='force recalculation of saliency maps'
    )
    parser.add_argument(
        '--shuffle',
        dest='shuffle',
        action='store_true',
        help='generate the saliency maps in random order, useful if running '
        'results on multiple computers and saving to shared directory.',
    )
    parser.add_argument(
        '--script', dest='file',
        default=None,
        help='override the single-gpu script to call (advanced)',
    )

    args = parser.parse_args()
    args.gpus = [int(x) for x in args.gpus]
    run_experiments(vars(args))
